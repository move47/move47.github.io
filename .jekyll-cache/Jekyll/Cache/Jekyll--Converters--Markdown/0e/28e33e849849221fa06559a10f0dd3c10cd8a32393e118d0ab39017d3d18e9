I"á<p>This is a technical blog and describes the technical details behind the GSoC project. In case you wish to see a <a href="https://wiki.mozilla.org/ReleaseEngineering/TryServer#How_to_push_to_try">developer‚Äôs guide</a> to <strong>use</strong> this feature only, kindly refer to this. Lastly, there is a <a href="/2016/07/20/gsoc-code-review.html">post</a> with a list of all the PRs in the project.</p>

<h2 id="treeherder">Treeherder</h2>

<p>Since the ‚ÄúAdd New Jobs‚Äù feature had been done earlier for BuildBot jobs, my major goal has been to create a parallel approach for TaskCluster jobs.</p>

<p>Unlike BuildBot jobs, TaskCluster jobs do not have a <code class="language-plaintext highlighter-rouge">buildername</code> property which can be used to uniquely identify a certain job. However, Dustin‚Äôs big-graph changes introduced <code class="language-plaintext highlighter-rouge">full-task-graph.json</code>, which has the magical <code class="language-plaintext highlighter-rouge">TaskLabel</code>. A typical task label looks like this - <code class="language-plaintext highlighter-rouge">TaskLabel==A1gDl4RUQriAf28c6gkuCw</code>.</p>

<p>Now task labels uniquely identify tasks in a push. They differ from task IDs. So if a single push has two tasks which do the same work, they would have identical task labels but different task IDs. Task IDs are produced when tasks are actually created. Another difference is that task labels are consistent across pushes. Task IDs are not, and can uniquely identify a particular task in a particular push.</p>

<p>So now on pressing ‚ÄúAdd New Jobs‚Äù, I pass the decision task id (only if it‚Äôs complete) to the Django API. The API downloads the <code class="language-plaintext highlighter-rouge">full-task-graph.json</code> file and sends back a list having both BuildBot jobs and TaskCluster jobs. <code class="language-plaintext highlighter-rouge">TaskLabel==&lt;...&gt;</code> is used as a <code class="language-plaintext highlighter-rouge">ref_name</code> to uniquely identify jobs.</p>

<p>Hence, the code for BuildBot is reused without further additions. However, two major changes have been made in the resulting pulse messages. We are passing down the Decision Task ID and a timestamp along with the list of requested jobs‚Äô <code class="language-plaintext highlighter-rouge">ref_name</code>s, which would be <code class="language-plaintext highlighter-rouge">buildername</code> for BB and <code class="language-plaintext highlighter-rouge">TaskLabel==&lt;...&gt;</code> for TaskCluster.</p>

<p>TaskCluster jobs only show on <code class="language-plaintext highlighter-rouge">try</code> pushes due to a UI restriction imposed. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1286894">Bug 1286894</a> has been filed to decide how to implement this feature on other repositories.</p>

<p>You can go ahead and try out the ‚ÄúAdd New Jobs‚Äù feature. You can see the Pulse messages on <a href="https://tools.taskcluster.net/pulse-inspector/#!((exchange:exchange/treeherder/v1/resultset-runnable-job-actions,routingKeyPattern:%23))">this</a> exchange.</p>

<h2 id="pulse-actions--mozci">Pulse Actions / MozCI</h2>

<p>Like before, Pulse Action continues to listen to these pulse messages generated by Treeherder. It now separates TaskCluster job requests by checking whether the <code class="language-plaintext highlighter-rouge">ref_name</code> starts with <code class="language-plaintext highlighter-rouge">TaskLabel==</code> or not.</p>

<p>TaskCluster jobs are then separated. MozCI reads the list of task labels and the Decision Task ID. It downloads <code class="language-plaintext highlighter-rouge">action.yml</code> a file which is YAML representation of Action Tasks (explained in next section). <code class="language-plaintext highlighter-rouge">and</code> are appropriately replaced with the Decision Task ID received in the Pulse Message and a comma separated list of requested task labels.</p>

<p>This is converted to a JSON task and scheduled using python TaskCluster client. The resulting task shows up on Treeherder as an <strong>Action Task</strong>.</p>

<h2 id="taskcluster">TaskCluster</h2>

<p>This describes the technical process in-tree, which enable the scheduling of Action Tasks.</p>

<p>The major change here is the addition of a <code class="language-plaintext highlighter-rouge">mach</code> command, <code class="language-plaintext highlighter-rouge">mach taskgraph action-task</code>. This command accepts two parameters, <code class="language-plaintext highlighter-rouge">decision-id</code> and <code class="language-plaintext highlighter-rouge">task-labels</code>.</p>

<p>This command is parsed and processed in <a href="https://dxr.mozilla.org/mozilla-central/source/taskcluster/taskgraph/action.py">taskcluster/takgraph/action.py</a>. The decision task ID is used to download the full-task-graph file along with the list of exisiting tasks.</p>

<p>Based on the set of task labels requested, the full-task-graph is simplified to leave just the nodes requested along with its dependencies. After this, the graph goes through an optimization procedure where all nodes present in the original push (procured from the task-to-label file in the decision task) are removed unless specially requested by the user.</p>

<p>Once the graph is optimized, the dependencies are replaced with appropriate task IDs and TaskCluster schedules this graph in the same push. The requested jobs then show up on Treeherder.</p>
:ET